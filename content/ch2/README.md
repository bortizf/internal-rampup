# Networking and Operating System
As a Devops Engineer you need to know how data communication works at a high level. This will help you to debug network-related issues, such as connectivity between them, services, and more. Plus, you will build the foundation (along with Virtualization) of your understanding of Cloud Computing.  
On the other hand, you will frequently be in front of a terminal with Bash or Powershell, or in your Cloud's terminal. You will hear about standard input or output (I/O). You will also need to have a control of the processes running on your systems, and will eventually work with some form of virtualization. That is why we believe it is important for you to know the basic concepts of an operating system, what parts it is made up of, and how they are related.

## Networking
Networking structure is so complex that it is divided into multiple layers. Each layer has specific responsabilities and relies on lower layers to provide services. The definition of the layers is described by TCP/IP and OSI model. We will use the TCP/IP Model.
* Application layer: contains high-level protocols that applications and servers use to communicate. For example, Hypertext Transfer Protocol (HTTP) or Transport Layer Security (TLS). 
* Transport layer: includes specifications on how the data will be break into packets, and how these packets will be reassembly. Also, it performs data integrity checking. Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) are the most common protocols in this layer. 
* Internet or network layer: once the packets are ready to be sent, this layer defines how to move those packets from a source to a destination host. The Internet Protocol (IP) is used to perform this task.
* Link layer: defines how to send data across a wired or wireless link. For example, Ethernet or 802.11 (WiFi).

## Operating System
An operating system acts as an intermediary between high-level programs (Firefox, Terminal, Spreadsheets, and so on) and your computer's hardware. It decides what process runs next, what part of the main memory allocates to a process, and what devices are compatible with the system.  
Processes are crucial because are the ones which tell to the computer what operations to perform. A *process* is a program running in main memory (RAM). The set of processes running on a system make up the *user space* - parts of the RAM that user processes can access. For example, a web server runs in the user space.  These processes are managed by the kernel. The kernel is the core of the operating system. It's the one which tells to the CPU where to look for its next task. The memory area that only the kernel can access is called *kernel space*. The kernel mainly has 4 functions:
* Process management: defines when a process is started, paused, resumed, scheduled, and terminated. They have more than two states (starting and terminating) because in practice a process uses the CPU for a small period of time (*time slice*), then it pauses and another process can start using the CPU, and so on. The act of pausing one process and starting (or resuming) another one is called a *context switch*. The kernel is responsible for context switching. This gives us the ilusion that multiple processes are running at the same time (*multitasking*)
* Memory management: modern CPUs include a memory management unit (MMU) that let us use a memory access scheme called *virtual memory*. In this scheme, a process does not directly access the physical memory location. The kernel sets up each process to act as if it had an entire machine to itself. The virtual addresses are mapped to translate to the physical ones. The kernel has to mantain and alter this memory address map.
* Device management: the kernel manages all hardware devices so that user processes can interact with them. A device a driver is a software that describes how to use and control a particular device. Those drivers are located in the kernel.
* System calls: in order to interact with the kernel, user processes have to use special functions called *system calls*. For example, through them processes can open (*open()*), read (*read()*), and write (*write()*) files. Processes are created through *fork()* and *exec()* system calls.

<p align="center">
<img src=imgs/fork-exec-exit-wait.png >
</p>